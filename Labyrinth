#include <iostream>
#include <vector>
#include <memory>
#include <cstdlib>
#include <ctime>
#include <conio.h>
#include <string>

using namespace std;

// Типы клеток игрового поля
enum class Cell { EMPTY, WALL, PLAYER, ENEMY, EXIT, TREASURE };

// Базовый интерфейс для всех игровых сущностей (игроков, врагов и т.д.)
class IEntity {
public:
    virtual ~IEntity() = default; // Виртуальный деструктор для корректного удаления

    // Получение урона сущностью
    virtual void takeDamage(int damage) = 0;

    // Проверка, жива ли сущность
    virtual bool isAlive() const = 0;

    // Получение текущего здоровья
    virtual int getHealth() const = 0;

    // Получение имени сущности
    virtual const string& getName() const = 0;
};

// Класс игрока, реализующий интерфейс IEntity
class Player : public IEntity {
private:
    int health = 150;   // Текущее здоровье игрока
    int armor = 20;     // Броня, уменьшает получаемый урон
    int energy = 100;   // Энергия для использования способностей
    int treasures = 0;  // Количество собранных сокровищ
    string name = "Игрок"; // Имя игрока

public:
    // Реализация метода получения урона с учетом брони
    void takeDamage(int damage) override {
        damage -= armor / 4; // Броня уменьшает урон на 25%
        if (damage < 5) damage = 5; // Минимальный урон 5 единиц
        health -= damage; // Применение урона к здоровью
    }

    // Проверка, жив ли игрок (здоровье > 0)
    bool isAlive() const override { return health > 0; }

    // Получение текущего здоровья
    int getHealth() const override { return health; }

    // Получение имени игрока
    const string& getName() const override { return name; }

    // Метод для сбора сокровища
    void addTreasure() {
        treasures++;    // Увеличение счетчика сокровищ
        health += 10;   // Восстановление здоровья
        energy += 20;   // Восстановление энергии

        // Ограничение максимальных значений
        if (health > 150) health = 150;
        if (energy > 100) energy = 100;
    }

    // Восстановление энергии
    void restore() {
        energy += 20;
        if (energy > 100) energy = 100; // Максимум 100 единиц энергии
    }

    // Отображение информации об игроке
    void display() const {
        cout << "Имя: " << name
             << " | HP: " << health
             << " | Броня: " << armor
             << " | Энергия: " << energy
             << " | Сокровища: " << treasures << endl;
    }

    // Получение текущего уровня энергии
    int getEnergy() const { return energy; }

    // Трата энергии на использование способности
    void useEnergy(int amount) { energy -= amount; }
};

// Класс врага, реализующий интерфейс IEntity
class Enemy : public IEntity {
private:
    int health;   // Здоровье врага
    int damage;   // Урон, который наносит враг
    string name;  // Имя врага

public:
    // Конструктор с базовыми значениями
    Enemy() : health(80), damage(20), name("Враг") {}

    // Получение урона врагом
    void takeDamage(int dmg) override {
        health -= dmg; // Уменьшение здоровья
        if (health < 0) health = 0; // Здоровье не может быть отрицательным
    }

    // Проверка, жив ли враг
    bool isAlive() const override { return health > 0; }

    // Получение текущего здоровья врага
    int getHealth() const override { return health; }

    // Получение имени врага
    const string& getName() const override { return name; }

    // Получение урона, который наносит враг
    int getDamage() const { return damage; }

    // Атака игрока врагом
    void attack(Player& player) {
        player.takeDamage(damage); // Нанесение урона игроку
        cout << name << " атакует! Урон: " << damage << endl; // Информационное сообщение
    }
};

// Интерфейс для отрисовки игрового состояния
class IRenderer {
public:
    // Отрисовка лабиринта и позиции игрока
    virtual void render(const vector<vector<Cell>>& maze, int px, int py) = 0;
    virtual ~IRenderer() = default;
};

// Интерфейс для генерации лабиринта
class IMazeGenerator {
public:
    // Генерация лабиринта заданного размера
    virtual vector<vector<Cell>> generate(int w, int h) = 0;
    virtual ~IMazeGenerator() = default;
};

// Интерфейс для обработки пользовательского ввода
class IInputHandler {
public:
    // Получение ввода от пользователя
    virtual char getInput() = 0;
    virtual ~IInputHandler() = default;
};

// Конкретная реализация отрисовщика для консоли
class ConsoleRenderer : public IRenderer {
public:
    // Реализация отрисовки в консоли
    void render(const vector<vector<Cell>>& maze, int px, int py) override {
        system("cls"); // Очистка консоли (Windows)
        cout << "ЛАБИРИНТ (w-вверх, s-вниз, a-влево, d-вправо)\n\n";

        // Проход по всем клеткам лабиринта
        for (int i = 0; i < maze.size(); i++) {
            for (int j = 0; j < maze[i].size(); j++) {
                // Если текущая клетка - позиция игрока
                if (i == px && j == py) {
                    cout << "P "; // Символ игрока
                } else {
                    // Отображение символа в зависимости от типа клетки
                    switch (maze[i][j]) {
                        case Cell::WALL: cout << "# "; break;     // Стена
                        case Cell::ENEMY: cout << "E "; break;    // Враг
                        case Cell::EXIT: cout << "X "; break;     // Выход
                        case Cell::TREASURE: cout << "T "; break; // Сокровище
                        default: cout << ". "; break;             // Пустая клетка
                    }
                }
            }
            cout << endl; // Переход на новую строку после отрисовки строки лабиринта
        }
    }
};

// Конкретная реализация генератора простого лабиринта
class SimpleMazeGenerator : public IMazeGenerator {
public:
    // Генерация лабиринта размером w x h
    vector<vector<Cell>> generate(int w, int h) override {
        // Создание двумерного вектора, заполненного пустыми клетками
        vector<vector<Cell>> maze(h, vector<Cell>(w, Cell::EMPTY));

        // Установка стен по периметру лабиринта
        // Вертикальные стены (левая и правая границы)
        for (int i = 0; i < h; i++) {
            maze[i][0] = maze[i][w-1] = Cell::WALL;
        }
        // Горизонтальные стены (верхняя и нижняя границы)
        for (int j = 0; j < w; j++) {
            maze[0][j] = maze[h-1][j] = Cell::WALL;
        }

        // Инициализация генератора случайных чисел
        srand(time(0));

        // Генерация случайных внутренних стен
        // Начинаем с индекса 2, чтобы оставить проходы у границ
        for (int i = 2; i < h-2; i++) {
            for (int j = 2; j < w-2; j++) {
                // 25% шанс создания стены
                if (rand() % 4 == 0) maze[i][j] = Cell::WALL;
            }
        }

        // Размещение выхода в правом нижнем углу
        maze[h-2][w-2] = Cell::EXIT;

        // Размещение трех сокровищ
        for (int i = 0; i < 3; i++) {
            int x, y;
            // Поиск случайной пустой клетки для сокровища
            do {
                x = 1 + rand() % (h-2); // Случайная координата X (1..h-3)
                y = 1 + rand() % (w-2); // Случайная координата Y (1..w-3)
            } while (maze[x][y] != Cell::EMPTY); // Повторять, пока клетка не пуста
            maze[x][y] = Cell::TREASURE;
        }

        // Размещение четырех врагов
        for (int i = 0; i < 4; i++) {
            int x, y;
            // Поиск случайной пустой клетки для врага
            do {
                x = 1 + rand() % (h-2);
                y = 1 + rand() % (w-2);
            } while (maze[x][y] != Cell::EMPTY);
            maze[x][y] = Cell::ENEMY;
        }

        return maze; // Возврат сгенерированного лабиринта
    }
};

// Конкретная реализация обработчика клавиатурного ввода
class KeyboardInputHandler : public IInputHandler {
public:
    // Получение символа с клавиатуры без ожидания Enter
    char getInput() override {
        return _getch(); // Функция для немедленного считывания клавиши
    }
};

// Система боя между игроком и врагом
class CombatSystem {
private:
    Player& player; // Ссылка на игрока
    Enemy enemy;    // Объект врага

public:
    // Конструктор, принимающий ссылку на игрока
    CombatSystem(Player& p) : player(p) {}

    // Основной метод проведения боя
    bool fight() {
        system("cls"); // Очистка экрана
        cout << "БОЙ С ВРАГОМ!\n";

        // Цикл боя продолжается, пока оба участника живы
        while (player.isAlive() && enemy.isAlive()) {
            // Отображение текущего состояния боя
            cout << "\nВаше HP: " << player.getHealth() << " | Энергия: " << player.getEnergy()
                 << "\nHP врага: " << enemy.getHealth() << endl;

            // Меню действий в бою
            cout << "1. Атаковать (-15 энергии, урон 25)\n";
            cout << "2. Защищаться (+10 брони на этот ход)\n";
            cout << "3. Спецприем (-30 энергии, урон 40)\n";
            cout << "Выберите действие: ";

            // Получение выбора игрока
            char choice = _getch();
            cout << choice << endl; // Эхо выбора

            // Обработка выбора игрока
            switch (choice) {
                case '1': // Обычная атака
                    if (player.getEnergy() >= 15) {
                        enemy.takeDamage(25);  // Нанесение урона врагу
                        player.useEnergy(15);  // Трата энергии
                        cout << "Вы атаковали! Урон 25\n";
                    } else {
                        cout << "Недостаточно энергии!\n";
                    }
                    break;
                case '2': // Защита
                    cout << "Вы защитились!\n";
                    // В текущей реализации защита не имеет механики
                    break;
                case '3': // Специальная атака
                    if (player.getEnergy() >= 30) {
                        enemy.takeDamage(40);  // Больший урон
                        player.useEnergy(30);  // Больше энергии
                        cout << "Спецприем! Урон 40\n";
                    } else {
                        cout << "Недостаточно энергии!\n";
                    }
                    break;
                default: // Некорректный ввод
                    cout << "Неверный выбор!\n";
                    break;
            }

            // Ход врага, если он еще жив
            if (enemy.isAlive()) {
                enemy.attack(player); // Враг атакует игрока
            }
        }

        // Определение результата боя
        if (player.isAlive()) {
            cout << "\nВраг повержен! Вы победили!\n";
            player.restore(); // Восстановление энергии после победы
            system("pause");  // Пауза для чтения сообщения
            return true;      // Игрок победил
        } else {
            cout << "\nВы проиграли бой!\n";
            system("pause"); // Пауза для чтения сообщения
            return false;     // Игрок проиграл
        }
    }
};

// Абстрактная фабрика для создания компонентов игры
class IGameFactory {
public:
    // Создание отрисовщика
    virtual unique_ptr<IRenderer> createRenderer() = 0;

    // Создание генератора лабиринта
    virtual unique_ptr<IMazeGenerator> createMazeGenerator() = 0;

    // Создание обработчика ввода
    virtual unique_ptr<IInputHandler> createInputHandler() = 0;

    virtual ~IGameFactory() = default;
};

// Конкретная фабрика для консольной версии игры
class ConsoleGameFactory : public IGameFactory {
public:
    // Создание консольного отрисовщика
    unique_ptr<IRenderer> createRenderer() override {
        return make_unique<ConsoleRenderer>();
    }

    // Создание простого генератора лабиринта
    unique_ptr<IMazeGenerator> createMazeGenerator() override {
        return make_unique<SimpleMazeGenerator>();
    }

    // Создание обработчика клавиатурного ввода
    unique_ptr<IInputHandler> createInputHandler() override {
        return make_unique<KeyboardInputHandler>();
    }
};

// Основной класс игры, управляющий всем игровым процессом
class MazeGame {
private:
    vector<vector<Cell>> maze;          // Двумерный массив лабиринта
    unique_ptr<IRenderer> renderer;     // Указатель на отрисовщик
    unique_ptr<IInputHandler> inputHandler; // Указатель на обработчик ввода
    Player player;                      // Объект игрока
    int playerX, playerY;               // Текущие координаты игрока
    bool gameRunning;                   // Флаг активности игрового цикла

public:
    // Конструктор, принимающий фабрику для создания компонентов
    MazeGame(unique_ptr<IGameFactory> factory)
        : renderer(factory->createRenderer())
        , inputHandler(factory->createInputHandler())
        , gameRunning(true) {

        // Создание генератора и генерация лабиринта
        auto generator = factory->createMazeGenerator();
        maze = generator->generate(15, 10); // Лабиринт 10 строк, 15 столбцов

        // Начальная позиция игрока (левый верхний угол внутри границ)
        playerX = 1;
        playerY = 1;
    }

    // Основной метод запуска игры
    void run() {
        // Главный игровой цикл
        while (gameRunning && player.isAlive()) {
            // Отрисовка текущего состояния
            renderer->render(maze, playerX, playerY);

            // Отображение статистики игрока
            player.display();

            // Легенда для символов на карте
            cout << "\nЛегенда: P-Вы, #-Стена, E-Враг, T-Сокровище, X-Выход\n";

            // Получение ввода от игрока
            char input = inputHandler->getInput();

            // Обработка ввода (перемещение)
            processInput(input);

            // Проверка клетки, на которую перешел игрок
            checkCurrentCell();
        }

        // Очистка экрана и вывод итогов
        system("cls");

        // Определение результата игры
        if (player.isAlive()) {
            cout << "ПОЗДРАВЛЯЕМ! ВЫ НАШЛИ ВЫХОД!\n";
        } else {
            cout << "ИГРА ОКОНЧЕНА. ВЫ ПРОИГРАЛИ.\n";
        }

        // Вывод финальной статистики
        cout << "Итоговая статистика:\n";
        player.display();

        // Пауза перед завершением
        system("pause");
    }

private:
    // Обработка пользовательского ввода для перемещения
    void processInput(char input) {
        int newX = playerX; // Новая координата X
        int newY = playerY; // Новая координата Y

        // Изменение координат в зависимости от нажатой клавиши
        switch (input) {
            case 'w': newX--; break; // Движение вверх
            case 's': newX++; break; // Движение вниз
            case 'a': newY--; break; // Движение влево
            case 'd': newY++; break; // Движение вправо
        }

        // Проверка, можно ли переместиться на новую клетку
        // Перемещение возможно, если клетка не является стеной
        if (maze[newX][newY] != Cell::WALL) {
            playerX = newX; // Обновление координаты X
            playerY = newY; // Обновление координаты Y
        }
    }

    // Проверка типа клетки, на которой находится игрок
    void checkCurrentCell() {
        // Ссылка на текущую клетку для возможного изменения
        Cell& cell = maze[playerX][playerY];

        // Обработка в зависимости от типа клетки
        switch (cell) {
            case Cell::ENEMY: {
                // Встреча с врагом - начало боя
                cout << "\nВстречен враг! Нажмите любую клавишу для боя...\n";
                _getch(); // Ожидание подтверждения игрока

                // Создание системы боя и запуск
                CombatSystem combat(player);
                if (combat.fight()) {
                    cell = Cell::EMPTY; // Удаление врага с карты после победы
                } else {
                    gameRunning = false; // Завершение игры при поражении
                }
                break;
            }

            case Cell::TREASURE: {
                // Нахождение сокровища
                cout << "\nНайдено сокровище! +10 HP, +20 энергии\n";
                player.addTreasure(); // Улучшение характеристик игрока
                cell = Cell::EMPTY;   // Удаление сокровища с карты
                system("pause");      // Пауза для чтения сообщения
                break;
            }

            case Cell::EXIT:
                // Достижение выхода - победа в игре
                gameRunning = false;
                break;

            default:
                // Для других типов клеток ничего не делать
                break;
        }
    }
};

// Точка входа в программу
int main() {
    setlocale(LC_ALL, "");

    try {
        // Создание фабрики для консольной игры
        auto factory = make_unique<ConsoleGameFactory>();

        // Создание и запуск игры
        MazeGame game(move(factory));
        game.run();

    } catch (const exception& e) {
        // Обработка исключений, если они возникнут
        cout << "Ошибка: " << e.what() << endl;
    }

    cout << "\nСпасибо за игру!\n";

    return 0;
}
